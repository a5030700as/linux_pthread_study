

关于前后台的概念问题：
	
	前台往往是指控制终端  也就是 希望用户层面 可以去控制进程 比如发送 停止 中断等等
	
	一个程序的运行 往往是和前台有联系的， 这样前台用户就可以去控制 在运行的 程序了
	但是 有时候 程序的打印的调试信息 显示到 显示器上 标准输出 这样 很不好

	因此 需要在 运行的 适合 修改 程序的标准输出 就好；
	
	./app > file.log 2>&1 &
	
	上面这句话 表明 修改了 app 的 标准输出 到 file.log(而不是屏幕) 并且 把标准错误 也输出到 file.log 然后 后台运行
	
	
第二：
	=====================================================
	
	卡顿的表现： 就是一个任务占用了CPU 导致 CPU切换不过来 
	CPU 空闲任务执行的 越多次 那么CPU性能越好
	
	=============================================
	
观察者模式：
	个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 
	典型的 一对多 模式； 

	观察者模式： 到底是一个怎么的过程呢？ 你有限的方法里面 怎么去实现 观察者模式呢？ 针对 C++语言来讲
	
	观察对象 客户端 耦合二者的subject?
	---都不对！---
	
	现在需要的是：
	你对观察者的 定义： 观察者 完成的 职责是 确定监听对象 并 转发 监听对象的 动态变化 给客户；
	
	这个模型 需要 三个 类去支持 
	
	虚继承  解决重复 代码复用的 继承问题
	
	虚函数 为了实现 在面向对象的时候 也可以面向方法编程
	抽象类 好像又退回到了 面向方法的思想了
	
	多态的前提 是继承后对虚函数的 重写。。。。重写。
	可以理解为 父类 开放了一个接口 子类去填充而已
	
	如果说继承 那么就会遇到一个 问题就是构造函数的 初始化顺序问题；
	
	--------------------------------------------------------------
	
	==================================================
	
	
	==================================================
	1 shell 启动的时候 回去读取~/.bashrc 配置文件 
	2 命令 之间 以; 或者 分行符号  区分
	
	echo 命令 执行 完毕后 默认添加 换行符号 
	单引号  所见即所得 
	双引号  支持转移扩展  $abc 
	 PATH="$PATH:/home/user/bin" 支持而已 变量展开 
	
	PATH通常定义在/etc/environment或/etc/profile或~/.bashrc中。如果需要在PATH中添加一条新路径。 
	解释了吧  终端设置环境变量 还是 账户设置环境变量 还是 系统级别设置
	
	let 命令 就是 C语言格式 运算命令 而已  let num1 + num2 
	test 命令也是 就是说 不需要去 变量展开解引用了  [ num1 + num2 ]
	
	==========================
	cmd > file.x 表示 1 标准输出重定向了 和 位置无关
	> 表示 修改 stdout 的问题
	=========================
	分析一下 这个命令的执行逻辑 ： 
	| 命令 修改了什么？
	------------------------
	ls -l | tee ls_test.txt | cat //tee 命令把 标准输出 保存在 ls_test.txt文件里；
	===================================================================
	
	 alias install='sudo apt-get install' #命令 别名 
	 
	 =======================================================
	 记住记住 shell都是 先拿配置 再工作的 ~/.bashrc
	 因此 不在 配置文件里面写的 都是当前终端生效 而已
	 ==========================================================

#!/bin/bash 
#文件名: time_take.sh 
start=$(date +%s) 
commands; 
statements; 
end=$(date +%s) 
difference=$(( end - start))

当需要 显示数字倒计时 的时候 不希望 输出一次 就打印一次回车 换行 
所以 echo -n 	
要知道echo 是默认换行

$理解为 穿透 或者 解引用 多好
===============================
脚本函数 指定入口就好 参数调用时指定

for each in $@/$*
	表现是一样的  都是遍历
而 
for each in “$@/$*”
	表现不一致了
前者 依旧是 是枚举 遍历 是产包 输出 
后者 是一个整体 是打包输出 
========================

另一种被称为反引用（有些人们也称它为反标记）的方法也可以用于存储命令输出：
cmd_output=`COMMANDS`

==========================================================================
read -p "promte input :" input_date;


====================================
	=========================================
	
	
