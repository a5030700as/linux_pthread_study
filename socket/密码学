
	
hash算法:
	md5---->摘要 主要验证 数据的完整性 唯一性

base64:
	数据的另外一种编码格式而已。把三字节对齐的数据 拆成 低六位 四字节对齐，不足的补 ' = '
	3 * 8 = 4 * 6 ; 6个bit表示 一个字节， 6 7 bit填充 0；
	
对称加密：
	DES
	AES 
	加密 解密都是一把锁
	f(key, raw_file) = ecry_file;
	f'(k, encode_file) = raw_file;

	key第一次传输 可以被中间人拦截， 不好

非对称加密：
	RSA
	公钥加密，私钥解密
	私钥加密，公钥解密

	C-----------------------S
	pub_key 请求------->
	pub_key 返回<-------
	
	S加密文件 是公开透明的，相当于裸奔。
	

密码学：
	https = + 对称加密 + 非对称加密 + CA认证；
	
	https 先向443端口 协商加密协议等等
	然后通过 80端口 完成数据传输

	浏览器 内置 证书公钥。
	
	433端口： 服务器会下发证书
	
	要利用好 客户端 发送公钥信息 只有服务器的私钥可以解锁
	因此， 客户端 发送 随机数 和 对称算法就好
	
	那么接下来的过程，中 服务器发给 客户端的 信息就不再是 公开透明的了 因为双方都约定好了 对称加密算法 和 钥匙。
	
	如果有一个中间人杀进来呢？ 自己制造一个 公私钥匙；
	这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。
	
	不一定要确定是 服务器吧？ 只是确保 这个数据包是 服务器发过来的。。。。
	这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。
	
	要解决两个问题：
	客户端如何确定 服务器的身份？
		从SRA------------> 如何证明服务器是私钥的持有者？
		客户端 指定 加密内容(一些随机数)让服务器加密，服务器加密返回给客户端， 客户端可以解析出来和原本指定内容一样，可以认定是服务器。（也可能是中间人）
		RSA 用于 确认服务器的身份；
		
		对称加密则
		用于解决 服务器 下发到 客户端 数据明文的问题。
		
		==========================================================================
		为了防止中间人（代理）的问题，
		引入了数字证书，数字证书 主要是证明 公钥的持有者。
		证书的主要是 完整性 唯一性 
		证书是被 CA机构的私钥加了密码的， 客户端可以通过公钥去解析出来
		解析出来之后 再通过 指纹算法 去识别对比 证书指纹 确定证书的 唯一性。		
		-----------------------		
		--------------------------------------------------------------------
		
	
 // 密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。
	我们说加密，是指对某个内容加密，加密后的内容还可以通过解密进行还原。
	这里主要解释一下签名，签名就是在信息的后面再加上一段内容，可以证明信息没有被修改过，怎么样可以达到这个效果呢？一般是对信息做一个hash计算得到一个hash值，注意，这个过程是不可逆的，也就是说无法通过hash值得出原来的信息内容。
	签名 可以理解为 附加信息 或者是 CRC校验码
	
	不怀好意的人也可以修改信息内容的同时也修改hash值，从而让它们可以相匹配，为了防止这种情况，hash值一般都会加密后(也就是签名)再和信息一起发送，以保证这个hash值不被修改。
	如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。

========================================
	
“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。

2.3 第三回合：
“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]

“服务器”->“客户”：{你的余额是100元}[私钥|RSA]

注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。

缺点： 服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。

这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示

因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

========================
step1： “客户”向服务端发送一个通信请求

“客户”->“服务器”：你好

  

step2： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有

“服务器”->“客户”：你好，我是服务器，这里是我的数字证书 

 

step3： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。

“客户”->“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。

“服务器”->“客户”：{一个随机字符串}[私钥|RSA]

 

step4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。

“服务器”->“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]

“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]

“服务器”->“客户”：{你好，你的余额是100元}[密钥|对称加密算法]

…… //继续其它的通信
=================================================================	

总结：
	
		客户端 从 CA证书里面获取 pub_key 
		
		然后 再 发送 一些随机数 让服务器去 用私钥 加密 以验证 对方是否 服务器
		
		通过之后
		
		客户端 下发 选择的 对称加密算法 以及 对称加密算法的秘钥
		
		后续的通信过程基本可以说是保密了
		
		自此！！！
		==============================================================
		
		
		
		
		
	
	
