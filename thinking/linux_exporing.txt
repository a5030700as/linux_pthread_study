====================================================
底层设备的数据 应该被系统保护起来 
用户态 和 内核态
=========================================、
不然 用户 乱搞一通 直接访问了 内核态数据 系统就乱了起来
	这个是一个 分层模型的 原则问题
	如果 位于顶层的用户可以直接 去访问底层的数据 那么分层模型就没必要存在了
==============================================================
内核驱动 只需要完成 主设备 的驱动 里面去区分次设备的信息就好；
让 用户 去创建节点信息 ，这个文件的属性里面 
根据 文件的 次设备 索引  加以区别设备
因为 都是 一套代码的复用而已。
===============================================================
在引入了 设备模型之后 
	完全可以在设备驱动的时候 顺便让内核 帮你创建设备文件而已，
	对内核而言 也是调用这个驱动， 具体索引识别是哪个设备 也是如此而已。
	一个 内核帮你 依次 创建 另外一个是用户自己 mknode来创建 设备节点而已
=========================================
关于读写为什么返回实际长度呢？
	因为实际缓冲区里面 数据 长度 和 用户的指定长度 很多情况是不一致的
	理解为 调用指定的 是一次读写的 最大长度（上限） 就好	
=========================================

关于 静态库 和 动态库 share的理解：

表现： 源码里面 包含头文件，就可以写代码了(这也就是 为什么大多数的 声明 都写在 头文件 编码的时候IDE 可以识别智能提示 什么的)， 编译的时候 需要 指定连接库 
库的本质就是 .o文件的集合

gcc 是 编译工具 集合，程序是 先编译 成.o 然后再通过 ar连接器连接的；

静态库： 每个程序都需要去静态库里面连接一次方法的实现，占用内存；
动态库： 程序运行的时候 跳转去指定的 内存区 运行代码就好， 多个程序 同时使用 一段代码区间而已 实现程序 和 库的分离；

====================================================
代码复用 避免重复造轮子的 最初表现了
=================================================================

=================================================================================================
