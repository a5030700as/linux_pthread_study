====================================================
底层设备的数据 应该被系统保护起来 
用户态 和 内核态
=========================================、
不然 用户 乱搞一通 直接访问了 内核态数据 系统就乱了起来
	这个是一个 分层模型的 原则问题
	如果 位于顶层的用户可以直接 去访问底层的数据 那么分层模型就没必要存在了
==============================================================
内核驱动 只需要完成 主设备 的驱动 里面去区分次设备的信息就好；
让 用户 去创建节点信息 ，这个文件的属性里面 
根据 文件的 次设备 索引  加以区别设备
因为 都是 一套代码的复用而已。
===============================================================
在引入了 设备模型之后 
	完全可以在设备驱动的时候 顺便让内核 帮你创建设备文件而已，
	对内核而言 也是调用这个驱动， 具体索引识别是哪个设备 也是如此而已。
	一个 内核帮你 依次 创建 另外一个是用户自己 mknode来创建 设备节点而已
=========================================
关于读写为什么返回实际长度呢？
	因为实际缓冲区里面 数据 长度 和 用户的指定长度 很多情况是不一致的
	理解为 调用指定的 是一次读写的 最大长度（上限） 就好
	
=========================================
