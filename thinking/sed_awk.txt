
sed是处理文件的工具， 是对文本文件的 增删改查操作
	其中 查 是增删改的 前提， 也就是说 正则表达式 是操作的前提； 或者 行定位是 操作的前提；

sed 's/aabb/hello/' a.txt > b.txt; // 就是说 把a.txt 里面包含 aabb 的行 修改为 b.txt

宏观上： 处理哪个文件 处理完的数据 丢到哪个个文件？
微观上： 每一行应该怎么处理？ 正则表达式的编辑内容问题；

正则表达式 元字符 的三个 角度类型， 字符类型 字符出现的次数 字符出现的位置； 去描述一个子串！！！！！


=================================================================
sed 工作模式： 扫描文件 逐行处理 结果整体输出到默认的 标准设备里面

这个简单例子需要理解的是 ：
	> 修改了 sed的默认输出 因此不会显示在屏幕上 如果指定输出 文件 则会 输出修改的文件到标准输出里面；
	
直接看需求吧:
	修改 a 文件 把 结果保存到 b文件 
	sed 's/aabb/hello/' a.txt > b.txt;
	
	修改 a 文件 只把处理的行 结果保存到 b文件
	sed  -n 's/aabb/hello/p' a.txt > b.txt;
	
//如果不指定 -n 选项的 话 那么 满足条件的 修改行 将会被输出两次到指定的文件里面 
//基本上 工具选项-n 和  命令选项 都是搭配来使用的
	sed  's/aabb/hello/p' a.txt > b.txt;
	
	snail@ubuntu:~/rootfs/test_sed$ cat a.txt
	one:nimagea;aljdhs
	two:nimageb
	three:wangnalipao
	four:llllll

	snail@ubuntu:~/rootfs/test_sed$ sed 's/one/111/p' a.txt > b.txt
	snail@ubuntu:~/rootfs/test_sed$ ls
	a.txt  a.txt.bak  b.txt  one-np.txt  one-n.txt  one.txt
	snail@ubuntu:~/rootfs/test_sed$ cat b.txt 
	111:nimagea;aljdhs
	111:nimagea;aljdhs
	two:nimageb
	three:wangnalipao
	four:llllll

============================================================================
	删除满足条件的行 
	//这里是 先查找  后操作 和 s/aaa/1111/ 这个 先指定操作 后查找不一样 
	sed '/one/d'         
	
	=========================================================================
	sed -i 说明处理结果 替换当前的文本 也就是覆盖的方式
	
	sed -n 如果 后面没指定 > 输出文件 也就是使用sed的默认输出  到屏幕上
	-n 是指 nor print 不输出的意思
	因此 -n 和 > 同时输出 
	结果就是 处理结果 不输出 指定文件 只是 虚晃一枪罢了。 
	-n 是 不输出 而不是输出到哪里。 因此 指定文件是 没用的 
	
snail@ubuntu:~/rootfs/test_sed$ cat a.txt
one:nimagea;aljdhs
two:nimageb
three:wangnalipao
four:llllll

snail@ubuntu:~/rootfs/test_sed$ sed -n 's/one/111/' > bb.txt
^C
snail@ubuntu:~/rootfs/test_sed$ sed -n 's/one/111/' a.txt > bb.txt
snail@ubuntu:~/rootfs/test_sed$ cat -n bb.txt 
snail@ubuntu:~/rootfs/test_sed$ 

	以上: 
  shell 里面的  && ||
  如果失败 || 则 执行后面的
  如果成功 && 则 执行 后面的 
  这种模式 相当于 
  while ( && ) 这里的话 要看到 短路与 的优势啊
	====================================================================
	
